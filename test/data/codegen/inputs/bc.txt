N int

P int

edges int[N][SparseList[N]]

source int

Let Init() -> (frontier_list int[N][SparseList[N]], num_paths int[N], deps int[N], visited int[N])
    num_paths[j] = (j == source)
    deps[j] = 0
    visited[j] = (j == source)
    frontier_list[r][j] = (r == 1 && j == source)
End

Let Forward_Step(frontier_in int[SparseList[N]], frontier_list int[N][SparseList[N]], num_paths int[N], visited int[N], round int) -> (frontier int[SparseList[N]], forward_frontier_list int[N][SparseList[N]], forward_num_paths int[N], forward_visited int[N], forward_round int)
	frontier[j] = edges[j][k] * frontier_list[round - 1][k] * (visited[j] == 0) | k:(CHOOSE, 0)
	forward_frontier_list[r][j] = frontier[j] * (r == round) + frontier_list[r][j] * (r != round)
	forward_num_paths[j] = edges[j][k] * frontier_list[round - 1][k] * (visited[j] == 0) * num_paths[k] | k:(+, num_paths[j])
	forward_visited[j] = edges[j][k] * frontier_list[round-1][k] * (visited[j] == 0) | k:(CHOOSE, visited[j])
	forward_round = round + 1
End

Let Forward(frontier_list int[N][SparseList[N]], num_paths int[N], visited int[N]) -> (dummy int[N], new_forward_frontier_list int[N][SparseList[N]], new_forward_num_paths int[N], new_forward_visited int[N], new_forward_round int)
	dummy[j] = 0
	_, new_forward_frontier_list, new_forward_num_paths, new_forward_visited, new_forward_round = Forward_Step*(dummy, frontier_list, num_paths, visited, 2) | (#2[#5-1] == 0)
End

Let Backwards_Vertex(frontier_list int[N][SparseList[N]], num_paths int[N], deps int[N], visited int[N], round int) -> (backward_deps int[N], backward_visited int[N], backward_round int)
        backward_deps[j] = deps[j] + ifelse(num_paths[j] != 0, frontier_list[round - 1][j] / num_paths[j], 0)
		backward_visited[j] = CHOOSE(frontier_list[round - 1][j], visited[j])
		backward_round = round - 1
End

Let Backwards_Edge(frontier_list int[N][SparseList[N]], num_paths int[N], deps int[N], visited int[N], round int) -> (backward_deps int[N])
	backward_deps[j] = edges[k][j] * frontier_list[round][k] * (visited[j] == 0) * deps[k] * (j != source) | k:(+, deps[j])
End

Let Backward_Step(frontier_list int[N][SparseList[N]], num_paths int[N], deps int[N], visited int[N], round int, dummy int[N]) -> (final_frontier_list int[N][SparseList[N]], final_num_paths int[N], final_deps int[N], final_visited int[N], final_round int, backward_deps int[N])
	final_frontier_list[r][j] = frontier_list[r][j]
	final_num_paths[j] = num_paths[j]
	backward_deps, final_visited, final_round = Backwards_Vertex(frontier_list, num_paths, deps, visited, round)
	final_deps = Backwards_Edge(frontier_list, num_paths, backward_deps, final_visited, final_round)
End

Let ComputeFinal(deps int[N], num_paths int[N]) -> (new_deps int[N])
    new_deps[i] = ifelse(num_paths[i] != 0, deps[i] * num_paths[i] - 1, 0)
End

{Final Result}
Let Main() -> (result int[N], final_deps int[N], final_num_paths int[N], frontier_list int[N][SparseList[N]], final_frontier_list int[N][SparseList[N]], final_visited int[N], num_paths int[N], deps int[N], visited int[N], forward_frontier_list int[N][SparseList[N]], forward_num_paths int[N], forward_round int, final_round int, d int[N], v int[N], new_visited int[N], dummy int[N])
	frontier_list, num_paths, deps, visited = Init()
	_, forward_frontier_list, forward_num_paths, _, forward_round = Forward(frontier_list, num_paths, visited)
	new_visited[i] = 0
	dummy[i] = 0
	final_frontier_list, final_num_paths, final_deps, final_visited, final_round, _ = Backward_Step*(forward_frontier_list, forward_num_paths, deps, new_visited, forward_round, dummy) | (#5 == 2)
    d, v = Backwards_Vertex(final_frontier_list, final_num_paths, final_deps, final_visited, final_round)
    result = ComputeFinal(d, final_num_paths)
End

